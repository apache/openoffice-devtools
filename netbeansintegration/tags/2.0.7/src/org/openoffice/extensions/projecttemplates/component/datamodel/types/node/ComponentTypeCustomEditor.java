/**************************************************************
 * 
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * 
 *************************************************************/

package org.openoffice.extensions.projecttemplates.component.datamodel.types.node;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.PropertyVetoException;
import java.beans.VetoableChangeListener;
import java.util.StringTokenizer;
import javax.swing.DefaultComboBoxModel;
import javax.swing.tree.TreeSelectionModel;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.propertysheet.PropertyEnv;
import org.openide.explorer.propertysheet.editors.EnhancedCustomPropertyEditor;
import org.openide.explorer.view.BeanTreeView;
import org.openide.nodes.Node;
import org.openide.util.NbBundle;
import org.openoffice.extensions.projecttemplates.component.ComponentWizardIterator;
import org.openoffice.extensions.util.LogWriter;
import org.openoffice.extensions.util.datamodel.NbNodeObject;
import org.openoffice.extensions.util.datamodel.PolyStruct;
import org.openoffice.extensions.util.datamodel.PropertyContainer;
import org.openoffice.extensions.util.datamodel.properties.UnknownOpenOfficeOrgPropertyException;
import org.openoffice.extensions.util.typebrowser.logic.UnoTypes;
import org.openoffice.extensions.util.typebrowser.logic.TypeBrowserChildren;
import org.openoffice.extensions.util.typebrowser.logic.TypeNode;

/**
 *
 * @author  sg128468
 */
public class ComponentTypeCustomEditor extends javax.swing.JPanel 
        implements ExplorerManager.Provider, PropertyChangeListener, 
        VetoableChangeListener, EnhancedCustomPropertyEditor {
    
    private ExplorerManager manager = new ExplorerManager();
    private PropertyEnv propertyEnv;
    private ComponentTypePropertyEditor editor;
    
//    private String selectedType;
    private TypeNode rootNode;

    // the return type, set into the editor
    private String type;
    
    /** Creates new form ComponentTypeCustomEditor */
    public ComponentTypeCustomEditor(ComponentTypePropertyEditor editor, 
            PropertyEnv propertyEnv) {
        initComponents();
        type = ""; // NOI18N
        this.propertyEnv = propertyEnv;
        this.editor = editor;
        propertyEnv.setState(PropertyEnv.STATE_INVALID);
        propertyEnv.addVetoableChangeListener(this);

//        NbNodeObject[] addNodes = this.comp.getDesignedTypes();
        
        // important: in the Resource Budle, entries for the type list
        // must have this order: all, ifc, enum, struct, consts
        this.rootNode = TypeNode.createRootNode(
                new String[] { 
                      UnoTypes.MODULE,
                      UnoTypes.INTERFACE,
                      UnoTypes.STRUCT,
                      UnoTypes.SIMPLE,
//                      TypeBrowser.ENUM,
//                      TypeBrowser.CONSTANTS,
                }
//                null
        );
  
//        2do: use this later!        
//        FeatureDescriptor desc = propertyEnv.getFeatureDescriptor();
        
        manager.setRootContext(rootNode);
        BeanTreeView typeView = (BeanTreeView)jScrollPane1;
        typeView.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        manager.addPropertyChangeListener(this);    
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        jScrollPane1 = new BeanTreeView();
        selectTypeComboBox = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        optionalCheckBox = new javax.swing.JCheckBox();
        ambiguousCheckBox = new javax.swing.JCheckBox();
        defaultedCheckBox = new javax.swing.JCheckBox();

        jScrollPane1.setBackground(new java.awt.Color(255, 255, 255));
        jScrollPane1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        selectTypeComboBox.setModel(new DefaultComboBoxModel(getComboBoxList()));
        selectTypeComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectTypeActionPerformed(evt);
            }
        });

        jLabel1.setLabelFor(selectTypeComboBox);
        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, NbBundle.getMessage(ComponentWizardIterator.class, "LBL_DisplayType"));

        org.openide.awt.Mnemonics.setLocalizedText(optionalCheckBox, NbBundle.getMessage(ComponentWizardIterator.class, "LBL_optionalCheckBox"));
        optionalCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        optionalCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        org.openide.awt.Mnemonics.setLocalizedText(ambiguousCheckBox, NbBundle.getMessage(ComponentWizardIterator.class, "LBL_ambiguousCheckBox"));
        ambiguousCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        ambiguousCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        org.openide.awt.Mnemonics.setLocalizedText(defaultedCheckBox, NbBundle.getMessage(ComponentWizardIterator.class, "LBL_defaultedCheckBox"));
        defaultedCheckBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        defaultedCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                        .add(jLabel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 215, Short.MAX_VALUE)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(selectTypeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 251, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 478, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .add(optionalCheckBox)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 125, Short.MAX_VALUE)
                        .add(ambiguousCheckBox)
                        .add(114, 114, 114)
                        .add(defaultedCheckBox)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(selectTypeComboBox, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jLabel1))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 167, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(optionalCheckBox)
                    .add(defaultedCheckBox)
                    .add(ambiguousCheckBox))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void selectTypeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectTypeActionPerformed

        int index = selectTypeComboBox.getSelectedIndex();
        switch (index) {
            case 1:
                TypeNode.setDisplayedTypes(new String[]{UnoTypes.INTERFACE});
                break;
            case 2:
                TypeNode.setDisplayedTypes(new String[]{UnoTypes.STRUCT});
                break;
            case 3:
                TypeNode.setDisplayedTypes(new String[]{UnoTypes.CONSTANTS});
                break;
            default:  // default: show all
                TypeNode.setDisplayedTypes(new String[]{
                      UnoTypes.INTERFACE,
                      UnoTypes.SIMPLE,
                      UnoTypes.STRUCT,
//                      TypeBrowser.ENUM,
//                      TypeBrowser.CONSTANTS,
                  });
        }
        // update UI
        Node node = manager.getExploredContext();
        if (node == null) {
            node = manager.getRootContext();
        }
        TypeBrowserChildren tbc = (TypeBrowserChildren)node.getChildren();
        tbc.update();
        
    }//GEN-LAST:event_selectTypeActionPerformed

    public ExplorerManager getExplorerManager() {
        return manager;
    }

    public void propertyChange(PropertyChangeEvent evt) {
        Node[] nodes = manager.getSelectedNodes();
        if (nodes != null && nodes.length > 0) {
            TypeNode node = (TypeNode)nodes[0];  // single tree selection

            if (node.getNodeType() != UnoTypes.MODULE_TYPE) { // do not add modules to this type
//                selectedType = getSelectedType();
                propertyEnv.setState(PropertyEnv.STATE_NEEDS_VALIDATION);
            }
            else {
//                selectedType = null;
                propertyEnv.setState(PropertyEnv.STATE_INVALID);
            }
        }
    }

    public void vetoableChange(PropertyChangeEvent evt) throws PropertyVetoException {
        if (PropertyEnv.PROP_STATE.equals(evt.getPropertyName()) &&
            PropertyEnv.STATE_VALID.equals(evt.getNewValue()) && 
                    PropertyEnv.STATE_NEEDS_VALIDATION.equals(evt.getOldValue())) { // OK pressed
            getSelectedTypeName();
            Node[] nodes = manager.getSelectedNodes();
            if (nodes != null && nodes.length > 0) {
                TypeNode node = (TypeNode)nodes[0];  // single tree selection
                if (node.getNodeType() == UnoTypes.POLY_STRUCT_TYPE) {
                    NbNodeObject[] nodeObjects = node.getDesignedTypes();
                    if (nodeObjects != null) { 
                        NbNodeObject polyStructObject = getOwnType(type, nodeObjects);
                        if (polyStructObject != null) {
                            PolyStruct plStruct = (PolyStruct)polyStructObject;
                            NewTemplateTypesDialog.start(editor, plStruct);
                        }
                        else {
                            // 2do for office poly struct types
                        }
                    }
                }
                else {
                    editor.setValue(type);
                }
            }
        }
    }

    public Object getPropertyValue() throws IllegalStateException {
        getSelectedTypeName();
        return type;
    }
    
//    public void addTemplateTypes(String polyStructTypes) {
//        this.type = polyStructTypes;
//    }
    
    private NbNodeObject getOwnType(String type, NbNodeObject[] nodeObjects) {
        // get own tyope from list
        for (int i=0; i<nodeObjects.length; i++) {
            PropertyContainer cont = (PropertyContainer)nodeObjects[i];
            try {
                // exception in the next line means it's not a poly struct and can be ignored
                String displName = cont.getSimpleProperty(PolyStruct.PROPERTY_CONTAINER_PACKAGE).concat(
                        ".").concat(cont.getSimpleProperty(PolyStruct.PROPERTY_CONTAINER_NAME)); // NOI18N
                if (type.indexOf(displName) != -1) {
                    return nodeObjects[i];
                }
            } catch (UnknownOpenOfficeOrgPropertyException ex) {
                LogWriter.getLogWriter().log(LogWriter.LEVEL_INFO, ex.getMessage());
            }
        }
        return null;
    }
    
    private String[] getComboBoxList() {
        String list = NbBundle.getMessage(ComponentWizardIterator.class, "LST_TypeList");
        StringTokenizer t = new StringTokenizer(list, " "); // NOI18N
        String[] retVal = new String[t.countTokens()];
        for (int i=0; t.hasMoreTokens(); i++) {
            retVal[i] = t.nextToken();
        }
        return retVal;
    }
    
    private void getSelectedTypeName() {
        Node[] nodes = manager.getSelectedNodes();
        type = ""; // NOI18N
        if (nodes != null && nodes.length > 0) {
            TypeNode node = (TypeNode)nodes[0];  // single tree selection

            if (node.getNodeType() != UnoTypes.MODULE_TYPE) { // do not add modules to this type
                type = node.getHierarchicalName();
            }
        }
        if (optionalCheckBox.isSelected()) {
            // add optional poly struct
            type = "com.sun.star.beans.Optional< ".concat(type).concat(" >"); // NOI18N
        }
        if (ambiguousCheckBox.isSelected()) {
            // ad ambiguous poly struct
            type = "com.sun.star.beans.Ambiguous< ".concat(type).concat(" >"); // NOI18N
        }
        if (defaultedCheckBox.isSelected()) {
            // ad defaulted poly struct
            type = "com.sun.star.beans.Defaulted< ".concat(type).concat(" >"); // NOI18N
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox ambiguousCheckBox;
    private javax.swing.JCheckBox defaultedCheckBox;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JCheckBox optionalCheckBox;
    private javax.swing.JComboBox selectTypeComboBox;
    // End of variables declaration//GEN-END:variables

    
}
